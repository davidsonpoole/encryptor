package com.davidsonpoole.encryptor;


import javax.crypto.KeyGenerator;
import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.security.Key;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;

public class Encryptor extends JFrame{
    private String filename, dir;
    private static int[] sbox =  {
        0x63 ,0x7c ,0x77 ,0x7b ,0xf2 ,0x6b ,0x6f ,0xc5 ,0x30 ,0x01 ,0x67 ,0x2b ,0xfe ,0xd7 ,0xab ,0x76
                ,0xca ,0x82 ,0xc9 ,0x7d ,0xfa ,0x59 ,0x47 ,0xf0 ,0xad ,0xd4 ,0xa2 ,0xaf ,0x9c ,0xa4 ,0x72 ,0xc0
                ,0xb7 ,0xfd ,0x93 ,0x26 ,0x36 ,0x3f ,0xf7 ,0xcc ,0x34 ,0xa5 ,0xe5 ,0xf1 ,0x71 ,0xd8 ,0x31 ,0x15
                ,0x04 ,0xc7 ,0x23 ,0xc3 ,0x18 ,0x96 ,0x05 ,0x9a ,0x07 ,0x12 ,0x80 ,0xe2 ,0xeb ,0x27 ,0xb2 ,0x75
                ,0x09 ,0x83 ,0x2c ,0x1a ,0x1b ,0x6e ,0x5a ,0xa0 ,0x52 ,0x3b ,0xd6 ,0xb3 ,0x29 ,0xe3 ,0x2f ,0x84
                ,0x53 ,0xd1 ,0x00 ,0xed ,0x20 ,0xfc ,0xb1 ,0x5b ,0x6a ,0xcb ,0xbe ,0x39 ,0x4a ,0x4c ,0x58 ,0xcf
                ,0xd0 ,0xef ,0xaa ,0xfb ,0x43 ,0x4d ,0x33 ,0x85 ,0x45 ,0xf9 ,0x02 ,0x7f ,0x50 ,0x3c ,0x9f ,0xa8
                ,0x51 ,0xa3 ,0x40 ,0x8f ,0x92 ,0x9d ,0x38 ,0xf5 ,0xbc ,0xb6 ,0xda ,0x21 ,0x10 ,0xff ,0xf3 ,0xd2
                ,0xcd ,0x0c ,0x13 ,0xec ,0x5f ,0x97 ,0x44 ,0x17 ,0xc4 ,0xa7 ,0x7e ,0x3d ,0x64 ,0x5d ,0x19 ,0x73
                ,0x60 ,0x81 ,0x4f ,0xdc ,0x22 ,0x2a ,0x90 ,0x88 ,0x46 ,0xee ,0xb8 ,0x14 ,0xde ,0x5e ,0x0b ,0xdb
                ,0xe0 ,0x32 ,0x3a ,0x0a ,0x49 ,0x06 ,0x24 ,0x5c ,0xc2 ,0xd3 ,0xac ,0x62 ,0x91 ,0x95 ,0xe4 ,0x79
                ,0xe7 ,0xc8 ,0x37 ,0x6d ,0x8d ,0xd5 ,0x4e ,0xa9 ,0x6c ,0x56 ,0xf4 ,0xea ,0x65 ,0x7a ,0xae ,0x08
                ,0xba ,0x78 ,0x25 ,0x2e ,0x1c ,0xa6 ,0xb4 ,0xc6 ,0xe8 ,0xdd ,0x74 ,0x1f ,0x4b ,0xbd ,0x8b ,0x8a
                ,0x70 ,0x3e ,0xb5 ,0x66 ,0x48 ,0x03 ,0xf6 ,0x0e ,0x61 ,0x35 ,0x57 ,0xb9 ,0x86 ,0xc1 ,0x1d ,0x9e
                ,0xe1 ,0xf8 ,0x98 ,0x11 ,0x69 ,0xd9 ,0x8e ,0x94 ,0x9b ,0x1e ,0x87 ,0xe9 ,0xce ,0x55 ,0x28 ,0xdf
                ,0x8c ,0xa1 ,0x89 ,0x0d ,0xbf ,0xe6 ,0x42 ,0x68 ,0x41 ,0x99 ,0x2d ,0x0f ,0xb0 ,0x54 ,0xbb ,0x16};

    private static int[] affine_matrix = {
            143,
            199,
            227,
            241,
            248,
            124,
            62,
            31,
    };

    /* Log table using 0xe5 (229) as the generator */
    private static int[] ltable = {
        0x00, 0xff, 0xc8, 0x08, 0x91, 0x10, 0xd0, 0x36,
                0x5a, 0x3e, 0xd8, 0x43, 0x99, 0x77, 0xfe, 0x18,
                0x23, 0x20, 0x07, 0x70, 0xa1, 0x6c, 0x0c, 0x7f,
                0x62, 0x8b, 0x40, 0x46, 0xc7, 0x4b, 0xe0, 0x0e,
                0xeb, 0x16, 0xe8, 0xad, 0xcf, 0xcd, 0x39, 0x53,
                0x6a, 0x27, 0x35, 0x93, 0xd4, 0x4e, 0x48, 0xc3,
                0x2b, 0x79, 0x54, 0x28, 0x09, 0x78, 0x0f, 0x21,
                0x90, 0x87, 0x14, 0x2a, 0xa9, 0x9c, 0xd6, 0x74,
                0xb4, 0x7c, 0xde, 0xed, 0xb1, 0x86, 0x76, 0xa4,
                0x98, 0xe2, 0x96, 0x8f, 0x02, 0x32, 0x1c, 0xc1,
                0x33, 0xee, 0xef, 0x81, 0xfd, 0x30, 0x5c, 0x13,
                0x9d, 0x29, 0x17, 0xc4, 0x11, 0x44, 0x8c, 0x80,
                0xf3, 0x73, 0x42, 0x1e, 0x1d, 0xb5, 0xf0, 0x12,
                0xd1, 0x5b, 0x41, 0xa2, 0xd7, 0x2c, 0xe9, 0xd5,
                0x59, 0xcb, 0x50, 0xa8, 0xdc, 0xfc, 0xf2, 0x56,
                0x72, 0xa6, 0x65, 0x2f, 0x9f, 0x9b, 0x3d, 0xba,
                0x7d, 0xc2, 0x45, 0x82, 0xa7, 0x57, 0xb6, 0xa3,
                0x7a, 0x75, 0x4f, 0xae, 0x3f, 0x37, 0x6d, 0x47,
                0x61, 0xbe, 0xab, 0xd3, 0x5f, 0xb0, 0x58, 0xaf,
                0xca, 0x5e, 0xfa, 0x85, 0xe4, 0x4d, 0x8a, 0x05,
                0xfb, 0x60, 0xb7, 0x7b, 0xb8, 0x26, 0x4a, 0x67,
                0xc6, 0x1a, 0xf8, 0x69, 0x25, 0xb3, 0xdb, 0xbd,
                0x66, 0xdd, 0xf1, 0xd2, 0xdf, 0x03, 0x8d, 0x34,
                0xd9, 0x92, 0x0d, 0x63, 0x55, 0xaa, 0x49, 0xec,
                0xbc, 0x95, 0x3c, 0x84, 0x0b, 0xf5, 0xe6, 0xe7,
                0xe5, 0xac, 0x7e, 0x6e, 0xb9, 0xf9, 0xda, 0x8e,
                0x9a, 0xc9, 0x24, 0xe1, 0x0a, 0x15, 0x6b, 0x3a,
                0xa0, 0x51, 0xf4, 0xea, 0xb2, 0x97, 0x9e, 0x5d,
                0x22, 0x88, 0x94, 0xce, 0x19, 0x01, 0x71, 0x4c,
                0xa5, 0xe3, 0xc5, 0x31, 0xbb, 0xcc, 0x1f, 0x2d,
                0x3b, 0x52, 0x6f, 0xf6, 0x2e, 0x89, 0xf7, 0xc0,
                0x68, 0x1b, 0x64, 0x04, 0x06, 0xbf, 0x83, 0x38 };

    /* Anti-log table: */
    private static int[] atable = {
        0x01, 0xe5, 0x4c, 0xb5, 0xfb, 0x9f, 0xfc, 0x12,
                0x03, 0x34, 0xd4, 0xc4, 0x16, 0xba, 0x1f, 0x36,
                0x05, 0x5c, 0x67, 0x57, 0x3a, 0xd5, 0x21, 0x5a,
                0x0f, 0xe4, 0xa9, 0xf9, 0x4e, 0x64, 0x63, 0xee,
                0x11, 0x37, 0xe0, 0x10, 0xd2, 0xac, 0xa5, 0x29,
                0x33, 0x59, 0x3b, 0x30, 0x6d, 0xef, 0xf4, 0x7b,
                0x55, 0xeb, 0x4d, 0x50, 0xb7, 0x2a, 0x07, 0x8d,
                0xff, 0x26, 0xd7, 0xf0, 0xc2, 0x7e, 0x09, 0x8c,
                0x1a, 0x6a, 0x62, 0x0b, 0x5d, 0x82, 0x1b, 0x8f,
                0x2e, 0xbe, 0xa6, 0x1d, 0xe7, 0x9d, 0x2d, 0x8a,
                0x72, 0xd9, 0xf1, 0x27, 0x32, 0xbc, 0x77, 0x85,
                0x96, 0x70, 0x08, 0x69, 0x56, 0xdf, 0x99, 0x94,
                0xa1, 0x90, 0x18, 0xbb, 0xfa, 0x7a, 0xb0, 0xa7,
                0xf8, 0xab, 0x28, 0xd6, 0x15, 0x8e, 0xcb, 0xf2,
                0x13, 0xe6, 0x78, 0x61, 0x3f, 0x89, 0x46, 0x0d,
                0x35, 0x31, 0x88, 0xa3, 0x41, 0x80, 0xca, 0x17,
                0x5f, 0x53, 0x83, 0xfe, 0xc3, 0x9b, 0x45, 0x39,
                0xe1, 0xf5, 0x9e, 0x19, 0x5e, 0xb6, 0xcf, 0x4b,
                0x38, 0x04, 0xb9, 0x2b, 0xe2, 0xc1, 0x4a, 0xdd,
                0x48, 0x0c, 0xd0, 0x7d, 0x3d, 0x58, 0xde, 0x7c,
                0xd8, 0x14, 0x6b, 0x87, 0x47, 0xe8, 0x79, 0x84,
                0x73, 0x3c, 0xbd, 0x92, 0xc9, 0x23, 0x8b, 0x97,
                0x95, 0x44, 0xdc, 0xad, 0x40, 0x65, 0x86, 0xa2,
                0xa4, 0xcc, 0x7f, 0xec, 0xc0, 0xaf, 0x91, 0xfd,
                0xf7, 0x4f, 0x81, 0x2f, 0x5b, 0xea, 0xa8, 0x1c,
                0x02, 0xd1, 0x98, 0x71, 0xed, 0x25, 0xe3, 0x24,
                0x06, 0x68, 0xb3, 0x93, 0x2c, 0x6f, 0x3e, 0x6c,
                0x0a, 0xb8, 0xce, 0xae, 0x74, 0xb1, 0x42, 0xb4,
                0x1e, 0xd3, 0x49, 0xe9, 0x9c, 0xc8, 0xc6, 0xc7,
                0x22, 0x6e, 0xdb, 0x20, 0xbf, 0x43, 0x51, 0x52,
                0x66, 0xb2, 0x76, 0x60, 0xda, 0xc5, 0xf3, 0xf6,
                0xaa, 0xcd, 0x9a, 0xa0, 0x75, 0x54, 0x0e, 0x01 };

    private static int[] rc = {0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36};

    private JButton open = new JButton("Open");

    public Encryptor() {
        JPanel p = new JPanel();
        open.addActionListener(new OpenL());
        p.add(open);
        Container cp = getContentPane();
        cp.add(p, BorderLayout.SOUTH);
        p = new JPanel();
        p.setLayout(new GridLayout(2, 1));
        JLabel title = new JLabel("Welcome to Davidson's Encryptor!");
        JLabel subtitle = new JLabel("Choose a file to encrypt:");
        p.add(title);
        p.add(subtitle);
        cp.add(p, BorderLayout.NORTH);
        this.setTitle("Davidson's Encryptor");
        this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        this.setSize(250, 110);
        this.setVisible(true);
    }

    class OpenL implements ActionListener {
        public void actionPerformed(ActionEvent e) {
            JFileChooser c = new JFileChooser();
            int dialog = c.showOpenDialog(Encryptor.this);
            if (dialog == JFileChooser.APPROVE_OPTION) {
                filename = c.getSelectedFile().getName();
                dir = c.getCurrentDirectory().toString();
                convertFile(Paths.get(dir + "/" + filename));
            }
            if (dialog == JFileChooser.CANCEL_OPTION) {
                filename = "You pressed cancel";
                dir = "";
                System.out.println(filename);
            }

        }
    }

    private static byte[] generate_AES_key() {
        Key key;
        SecureRandom rand = new SecureRandom();
        try {
            KeyGenerator generator = KeyGenerator.getInstance("AES");
            generator.init(256, rand);
             key = generator.generateKey();
             return key.getEncoded();
        } catch (NoSuchAlgorithmException e) {
            System.out.println(e);
            return null;
        }
    }

    private static int[] expand_AES_key(byte[] key) {
        int[] result = new int[240]; // 120-word array (4 bytes per int)
        int rcon_iter = 1;
        int i = 0;
        while(i < 32) {
            result[i] = key[i]; // Copies key into first 32 bytes
            i++;
        }
        int[] temp = new int[4];
        while (i < 240) {
            for (int j=0; j<4; j++) {
                temp[j] = result[i+j-4];
            }
            if (i % 32 == 0) {
                temp = schedule_core(temp, rcon_iter++);
            }
            if (i % 32 == 16) {
                for (int j=0; j<4; j++) {
                    temp[j] = subWord(temp[j]);
                }
            }
            // assign prev 4 bytes of temp key to temp
            for (int j=0; j<4; j++) {
                result[i] = (result[i-32] ^ temp[j]);
                i++;
            }
        }
        return result;
    }

    private static int subWord(int initial) {
        /*
        // calculate multiplicative inverse using tables
        int next = (initial != 0) ? atable[(255 - ltable[initial])] : 0;

        int rev = 0;
        // reverse bits
        while (next > 0)
        {
            // bitwise left shift
            // 'rev' by 1
            rev <<= 1;

            // if current bit is '1'
            if ((int)(next & 1) == 1)
                rev ^= 1;

            // bitwise right shift
            //'n' by 1
            next >>= 1;
        }
        int final_result;
        // calculate s-box
        int[] result = new int[8];
        int[] curr_bits = new int[8];
        for (int x=0; x<8; x++) {
            // AND each row in sbox with input
            result[x] = rev & affine_matrix[x]; // returns a byte
            // go through sbox and get xor for each row and reverse
            int curr_bit = ((result[x] & (1 << 7)) / (1 << 7)) ^ ((result[x] & (1 << 6)) / (1 << 6));
            for (int j=2; j<8; j++) {
                curr_bit ^= ((result[x] & (1 << (7 - j))) / (1 << (7 - j)));
            }
            curr_bits[x] = curr_bit;
        }
        final_result = (curr_bits[0]);
        for (int x=1; x<8;x++) {
            final_result |= (curr_bits[x] << x);
        }
        final_result ^= 0x63;
        int last = final_result & 0xFF;

        return last;
         */
        return sbox[initial];
    }

    private static int[] rotWord(int[] initial) {
        // rotate by 8 bits
        int[] result = new int[4];
        for (int i=0; i<4; i++) {
            result[i] = initial[(i+1)%4];
        }
        return result;
    }

    private static int[] schedule_core(int[] in, int i) {
        // takes in 32-bit/4-byte word
        int[] rotated = rotWord(in);
        int[] result = new int[4];
        for (int j=0;j<4;j++) {

            result[j] = subWord(rotated[j]);
        }
        result[0] ^= rc[i];
        return result;
    }

    public static void main(String[] args) {
        //new Encryptor();
        //File file = new File("/Users/davidson/Documents/testFile.txt");
        //convertFile(file.toPath());
        //byte[] key = generate_AES_key();
        byte[] key = {
                0x00,
                0x01,
                0x02,
                0x03,
                0x04,
                0x05,
                0x06,
                0x07,
                0x08,
                0x09,
                0x0a,
                0x0b,
                0x0c,
                0x0d,
                0x0e,
                0x0f,
                0x10,
                0x11,
                0x12,
                0x13,
                0x14,
                0x15,
                0x16,
                0x17,
                0x18,
                0x19,
                0x1a,
                0x1b,
                0x1c,
                0x1d,
                0x1e,
                0x1f

        };
        int[] expanded_key = expand_AES_key(key);
        for (int b: expanded_key) {
            System.out.print(String.format("%02X ", b));
        }
    }

    public static void convertFile(Path pathName) {
        try {
            byte[] fileContent = Files.readAllBytes(pathName);
            byte[] encrypted = new byte[fileContent.length];
            int count = 0;
            for (byte bit: fileContent) {
                bit += count;
                encrypted[count] = bit;
                count++;
            }
            saveFile(encrypted);
        } catch (Exception e) {
            System.out.println(e);
        }
    }

    public static void saveFile(byte[] encrypted) {
        try {
            FileWriter fileWriter = new FileWriter("/Users/davidson/Documents/encryptedTestFile.txt");
            fileWriter.write(new String(encrypted));
            fileWriter.close();
        } catch (IOException e) {
            System.out.println("Error");
        }

    }
}
